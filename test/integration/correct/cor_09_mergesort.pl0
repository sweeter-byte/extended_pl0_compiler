program mergeSort;
{ Merge Sort using global arrays }
{ Uses arr for data and tmp for merging }
const SIZE := 10;
var arr[10], tmp[10], i;

procedure merge(left, mid, right);
  var i, j, k, done;
begin
  { Copy to temp array }
  i := left;
  while i <= right do begin
    tmp[i] := arr[i];
    i := i + 1
  end;
  
  { Merge back to arr }
  i := left;      { Left subarray index }
  j := mid + 1;   { Right subarray index }
  k := left;      { Merged array index }
  
  { Loop while both subarrays have elements }
  done := 0;
  while done = 0 do begin
    if i > mid then 
      done := 1
    else if j > right then
      done := 1
    else begin
      if tmp[i] <= tmp[j] then begin
        arr[k] := tmp[i];
        i := i + 1
      end
      else begin
        arr[k] := tmp[j];
        j := j + 1
      end;
      k := k + 1
    end
  end;
  
  { Copy remaining left elements }
  while i <= mid do begin
    arr[k] := tmp[i];
    i := i + 1;
    k := k + 1
  end;
  
  { Copy remaining right elements }
  while j <= right do begin
    arr[k] := tmp[j];
    j := j + 1;
    k := k + 1
  end
end;

procedure msort(left, right);
  var mid;
begin
  if left < right then begin
    mid := (left + right) / 2;
    call msort(left, mid);
    call msort(mid + 1, right);
    call merge(left, mid, right)
  end
end;

procedure printArray();
  var idx;
begin
  idx := 0;
  while idx < SIZE do begin
    write(arr[idx]);
    idx := idx + 1
  end
end;

begin
  { Initialize with unsorted data }
  arr[0] := 64;
  arr[1] := 34;
  arr[2] := 25;
  arr[3] := 12;
  arr[4] := 22;
  arr[5] := 11;
  arr[6] := 90;
  arr[7] := 1;
  arr[8] := 45;
  arr[9] := 33;
  
  call msort(0, SIZE - 1);
  call printArray()
end
{ Expected output:
1
11
12
22
25
33
34
45
64
90
}
