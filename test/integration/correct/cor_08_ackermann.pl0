program ackermann;
{ Ackermann Function - extreme recursion stress test }
{ A(m,n) = n+1                  if m = 0 }
{       = A(m-1, 1)             if m > 0 and n = 0 }
{       = A(m-1, A(m, n-1))     if m > 0 and n > 0 }
{ Warning: grows extremely fast! A(3,4) = 125, A(4,1) = 65533 }
var m, n, result;

procedure ack(am, an);
  var inner;
begin
  if am = 0 then
    result := an + 1
  else if an = 0 then
    call ack(am - 1, 1)
  else begin
    { First compute A(m, n-1) }
    call ack(am, an - 1);
    inner := result;
    { Then compute A(m-1, inner) }
    call ack(am - 1, inner)
  end
end;

begin
  { Test small values to avoid stack overflow }
  
  { A(0, 0) = 1 }
  call ack(0, 0);
  write(result);
  
  { A(0, 5) = 6 }
  call ack(0, 5);
  write(result);
  
  { A(1, 0) = A(0, 1) = 2 }
  call ack(1, 0);
  write(result);
  
  { A(1, 1) = A(0, A(1,0)) = A(0, 2) = 3 }
  call ack(1, 1);
  write(result);
  
  { A(1, 5) = 7 (A(1,n) = n + 2) }
  call ack(1, 5);
  write(result);
  
  { A(2, 0) = A(1, 1) = 3 }
  call ack(2, 0);
  write(result);
  
  { A(2, 1) = A(1, A(2,0)) = A(1, 3) = 5 }
  call ack(2, 1);
  write(result);
  
  { A(2, 2) = 7 (A(2,n) = 2n + 3) }
  call ack(2, 2);
  write(result);
  
  { A(2, 3) = 9 }
  call ack(2, 3);
  write(result);
  
  { A(3, 0) = A(2, 1) = 5 }
  call ack(3, 0);
  write(result);
  
  { A(3, 1) = A(2, A(3,0)) = A(2, 5) = 13 }
  call ack(3, 1);
  write(result);
  
  { A(3, 2) = 29 }
  call ack(3, 2);
  write(result);
  
  { A(3, 3) = 61 - This tests deep recursion }
  call ack(3, 3);
  write(result)
end
{ Expected output:
1
6
2
3
7
3
5
7
9
5
13
29
61
}
